----------------------------JAVASCRIPT-----------------------------------------------
1. Callback
hiểu nôm na là truyền hàm A này vào 1 hàm B khác , đến 1 lúc nào đó thì hàm A này sẽ được 
hàm B gọi lại, thường được dùng để lắng nghe event và xử lí bất đồng bộ'
2. Promise
- là 1 cơ chế trong Js giúp xử lí các tác vụ bất đồng bộ mà không rơi vào callback hell
- Ở 1 thời điểm nào đó thì promise sẽ có 3 trạng thái là 
		- pending : trạng thái (tt) đang chờ kết thúc
		- fulfilled: tráng thái xử lí thành công
		- rejected : trạng thái xử lí thất bại
- có thể nối nhiều promise bằng cách sử dụng .then() liên tiếp đằng sau
và kết quả trong hàm then() thứ nhất sẽ là đầu vào cho hàm then() thứ 2

* Promise.all()
- trả về 1 promise mới 
- promise chỉ được kết thúc khi các promise trong iterable kết thúc hoặc có 1 promise nào 
đó xử lý thất bại
- kết quả trả ra là 1 MẢNG chứa kết quả của tất cả các promise theo đúng thứ tự promise được
truyền vào
3. Async await
- là 1 cơ chế giúp bạn thực hiện các thao tác bất đồng bộ một cách tuần tự hơn, async/await 
vẫn sử dụng promise nhưng mã nguồn sẽ dễ đọc hơn :))
- để sử dụng thì ta phải khai báo hàm với từ khóa async. khi đó bên trong hàm ta mới có 
thể dùng await
- kết quả trả về của async func luôn là 1 promise

-------------NHỮNG CÂU HỎI----------------------
1. Sự khác nhau giữa var, let, const ? 
 * KHÁC NHAU VỀ BLOCK
 - nếu được khai báo trong func thì scope của nó là function/locally scoped,
nếu ngoài func thì scope của nó là globally scoped
 - let và const thì scope của nó là block scope, chứ không phải là globally hay locally scoped.

 * KHÁC NHAU VỀ VIỆC DEFINE LẠI 
  - var có thể được định nghĩa lại 1 cách dễ dàng, có thể dùng từ khóa 'var' hoặc không 
		vd : var foo = 100;
	             foo = 30; var foo = 102    => log ra sẽ là 102
  - let cũng có thể được định nghĩa(đn) lại , nhưng sẽ chặt chẽ hơn var ,khi đn lại thì không 
thể dùng từ khóa 'let' được
	      vd : let bar = 100, bar = 1000  ==> log sẽ ra 1000
  - const thì không thể được đn lại 
	
 * HOISTING
  - var được khởi tạo với giá trị là undefined 
  - let và const không có bất kì giá trị khởi tạo nào, nếu sử dụng biến let và const trước
khi khai báo thì sẽ gặp lỗi Reference Error

2. từ khóa this
- từ khóa this đề cập đến phạm vi hiện tại của nó (nơi nó được gọi).

3. == và ===
- '==' là so sánh xem có cùng giá trị hay không 
- '===' so sánh cả về giá trị và cả kiểu

4. trong JS có bao nhiều kiểu DL cơ bản 
- 6 kiểu: String, Boolean, Number , Null, Undefined, Object

5. number++ và ++number khác nhau như thế nào ? 
  - '++' được thêm làm hậu tố: đầu tiên nó trả về giá trị,sau đó tăng lên 1.
  - '++' được thêm làm tiền tố: đầu tiên tăng lên 1 đơn vị, sau đó trả về giá trị.

6. Closure là gì ?
- Closure là tính bao đóng, tính khép kín của hàm, thể hiện bằng tính chất: 1 hàm có thể ghi nhớ nơi nó được tạo
và truy cập được biến ở ngoài phạm vi của nó
7. Scope trong Js 
Các loại Scope (phạm vi) : 
	- Global : phạm vi toàn cầu
	- Code block : phạm vi khối mã với let, const
	- Local scope: phạm vi được tạo ra trong phần thân của hàm, khi hàm đó được gọi

8. Hoisting là gì
- Trong Js thì tất cả cú pháp khai báo biến, khai báo hàm thì đều được hoisted hết
- Hoisting là đề cập đến việc khai báo biến, khai báo hàm, thì biến , hàm được khai báo sẽ được đưa lên đầu phạm vi của chúng
+ Hoisting với biến var và func declaration: với biến var khi đc hoisted sẽ được khởi tạo giá trị undefined, với func
declaration thì phần khai báo sẽ được đưa lên => vì vậy có thể gọi hàm trước khi hàm đó được khai báo

==============
sum(6,9) ---> gọi hàm trước khi khai báo
// func declaration
function sum(a,b){
    return a + b
}
========================
+ Hoising với biến let, const
  Với biến let và const đều được hoisted, nhưng khi hoisted thì không được tạo giá trị mà nó được đưa vào 
"Temporal Dead Zone là vùng tạm thời không truy cập được" ==> sẽ báo lỗi cannot access "biến" before initiazation

9. strict mode
- Là chế độ nghiêm ngặt, là chế độ giúp code js an toàn hơn, khi bật chế độ này lên trong một số 
trường hợp có thể giúp tránh khỏi những lỗi do mình sơ ý để nó xảy ra
- Là 1 tính năng được ra mắt trong phiên bản ES6 
- Sử dụng:
 đặt từ khóa "use strict" ở : 
	+ đầu file js
	+ đầu phạm vi của hàm
	+ ngay đăng sau thẻ mở <script>